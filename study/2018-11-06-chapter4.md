# Chapter 4. Notification Chains

## Why notification chains?
* 커널 내에서 특정한 이벤트가 발생했을 때 이에 관심 있는 여러 서브 시스템에 효율적으로 전파할 방법이 필요
* 책의 예제. Network Topology가 달라져 Interface가 실패할 때 라우팅 서브시스템에 알리는 역할을 맡음
* Javascript의 addEventListener()와 유사한 방식

## Overview
* Notified(알림을 받는 측): Notifier에 구독을 원하는 이벤트와 콜백 함수 제공
* Notifier(알림을 보내는 측): 해당 이벤트 발생 시 콜백 함수 호출

## Chain Definition
```c
struct notifier_block {
	int (*notifier_call)(struct notifier_block *nb, unsigned long action, void *data);
	struct notifier_block __rcu *next;
	int priority;
};
```

* Singly Linked-List 구조지만 우선순위가 있어 node insert 할 때 제자리를 찾아감

## Chain Registration

기능 | 함수 프로토타입
--- | ---
등록 | `int notifier_chain_register(struct notifier_block **list, struct notifier_block *n)`<br><br>**Wrappers**<br>`inetaddr_chain` `register_inetaddr_notifier`<br>`inet6addr_chain` `register_inet6addr_notifier`<br>`netdev_chain` `register_netdevice_notifier`
해제 | `int notifier_chain_unregister(struct notifier_block **nl, struct notifier_block *n)`<br><br>**Wrappers**<br>`inetaddr_chain` `unregister_inetaddr_notifier`<br>`inet6addr_chain` `unregister_inet6addr_notifier`<br>`netdev_chain` `unregister_netdevice_notifier`
알림 | `int notifier_call_chain(struct notifier_block **n, unsigned long val, void *v)`

* 각 체인마다 `notifier_block`는 우선순위에 의해 정렬된 리스트에 삽입됨
* 알림 체인에 대한 접근은 `notifier_lock`에 의해 보호됨

## Event Notification
* linux/kernel/notifier.c에 정의된 `notifier_call_chain()`이 수행

```c
static int notifier_call_chain(struct notifier_block **nl,
			       unsigned long val, void *v,
			       int nr_to_call, int *nr_calls)
{
	int ret = NOTIFY_DONE;
	struct notifier_block *nb, *next_nb;

	nb = rcu_dereference_raw(*nl);

	while (nb && nr_to_call) {
		next_nb = rcu_dereference_raw(nb->next);

		ret = nb->notifier_call(nb, val, v);

		if (nr_calls)
			(*nr_calls)++;

		if (ret & NOTIFY_STOP_MASK)
			break;
		nb = next_nb;
		nr_to_call--;
	}
	return ret;
}
```

* `n`: 알림 체인
* `val`: 이벤트 타입
* `v`: Custom Input Parameter. 어떤 데이터도 받을 수 있도록 `void *` 타입으로 선언

### Return Code
* `NOTIFIER_OK`: 잘 처리됨
* `NOTIFIER_DONE`: 관심 없는 알림
* `NOTIFIER_BAD`: 문제 발생. 콜백 호출 중지.
* `NOTIFIER_STOP`: 잘 처리됨. 콜백 호출 중지.
* `NOTIFIER_STOP_MASK`: 콜백 호출 중지를 나타내는 Flag

## Notification Chains Type
* `Blocking Notifier Chain`: 콜백이 프로세스 컨텍스트에서 실행 (Block/Sleep 가능)
* `SRCU Notifier Chain`: `Blocking Notifier Chain`과 유사하나 `SRCU`(Sleepable Read-Copy Update) 사용을 통해 실행 최적화 ([관련 정보](https://lwn.net/Articles/190936/))
* `Atomic Notifier Chain`: 콜백이 인터럽트/원자적 컨텍스트에서 실행 (Spinlock 사용; Block/Sleep 불가능)
* `Raw Notifier Chain`: 콜백에서 Lock 없음. Caller 측에 동기화 책임

## Notification Chains for Networking Subsystems
* `inetaddr_chain`: 로컬 인터페이스 IPv4 주소의 삽입, 삭제, 변경에 대한 알림 제공
* `netdev_chain`: 네트워크 장치의 등록 상태에 대한 알림 제공

## Exercise
* 간단한 Character Device Driver를 커널 모듈 형태로 구현한다.
* `Blocking Notifier Chain`을 등록해 File I/O 시 이벤트를 발생시키고 커널 메시지를 통해 확인한다.
* [실행문 예시](https://gist.github.com/handrake/e82f3d20072ddf5be0dfba67be252b6b)를 차례대로 따라해 본다.